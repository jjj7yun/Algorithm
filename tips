###위상정렬

모든 노드를 방향성에 거스르지 않도록 순서대로 나열
정해진 우선순위에 맞게 순서 나열
ex) 선수과목 고려한 커리큘럼 
풀이 : heap , 진입차수 -1
      진입 차수 0 인 노드를 큐에 넣음
##최소신장트리:
크루스칼(간선 적을때), 프림(간선 많을때)
: 모든 요소를 연결할 때
### 크루스칼 알고리즘 ( 최소 신장 트리 알고리즘)
최소 비용으로 노드 연결
풀이 : 1. 거리에 따라 오름차순 정렬!!! 2.사이클 확인 
      사이클 발생 안하면 union_parent


###다익스트라
다익스트라는 전체 요소 연결 아님!!!! 한 요소에서 다른 요소로 가는 최단거리 찾기
최단경로찾기
heapq
현재 가장 가까운 노드를 저장하기 위해 우선순위 큐 사용

##정렬

####삽입정렬
리스트가 정렬되어 있으면 매우 빠름
보통 퀵정렬보다 비효율적이나 정렬되어 있으면 삽입정렬

####퀵정렬
가장 많이 사용
제일 빠름 
pivot - 절반씩 분할 (NlogN) , 최악은(N^2)
데이터가 무작위 : 빠름 / 정렬되어 있으면 매우 느림 ( 삽입이랑 반대)

####계수정렬
N 범위가 작을 때 매우 빠름 ( 가장 큰 데이터-가장 작은 데이터 차이 작을 때)
데이터 개수 N, 최대값 K 일때 시간복잡도 O(N+K)
최대 값 크기만큼 반복 수행 > 범위만 한정되어 있으면 빠름
count=[0]*(max(array)+1)
등장수만큼 count[array[i]]+=1 > print(count[i])


###
데이터 정렬 되어 있을 때만.
(시작점, 끝점, 중간점)
bisect모듈 사용!!
